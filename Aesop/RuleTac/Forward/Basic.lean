/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Util.Basic
import Aesop.Util.EqualUpToIds

namespace Aesop

open Lean Lean.Meta

/-
Forward rules must only succeed once for each combination of immediate
hypotheses; otherwise any forward rule could be applied infinitely often (if
it can be applied at all). We use the following scheme to ensure this:

- Whenever we add a hypothesis `h : T` as an instance of a forward rule, we also
  add an `implDetail` hypothesis `h' : T`.
- Before we add a hypothesis `h : T`, we check whether there is already an
  `implDetail` `h' : T`. If so, `h` is not added.

This scheme ensures that forward rules never add more than one hypothesis of
any given type. `h'` is added as an `implDetail`, rather than as a regular
hypothesis, to ensure that future rule applications do not change its type.

We also encode two pieces of data in the name of `h`: the name `h` and the
*forward depth* of `h`. The forward depth of a hypothesis not generated by
forward reasoning is 0. The forward depth of a hypothesis `h` generated by
forward reasoning is one plus the maximal forward depth of any hypothesis used
in the proof of `h`. The `saturate` tactic uses this information to limit its
reasoning depth.
-/

/-- Prefix of the regular hyps added by `forward`. -/
def forwardHypPrefix := `fwd

/-- Prefix of the `implDetail` hyps added by `forward`. -/
def forwardImplDetailHypPrefix := `__aesop.fwd

/-- Name of the `implDetail` hyp corresponding to the forward `hyp` with name
`fwdHypName` and depth `depth`. -/
def forwardImplDetailHypName (fwdHypName : Name) (depth : Nat) : Name :=
  .num forwardImplDetailHypPrefix depth ++ fwdHypName

/--
Parse a name generated by `forwardImplDetailHypName`, obtaining the
`fwdHypName` and `depth`.
-/
def matchForwardImplDetailHypName (n : Name) : Option (Nat × Name) :=
  match n.components with
  | `__aesop :: `fwd :: .num .anonymous depth :: components =>
    let name := Name.ofComponents components
    some (depth, name)
  | _ => none

/--
Check whether the given name was generated by `forwardImplDetailHypName`.
We assume that nobody else adds hyps with the `forwardImplHypDetailPrefix`
prefix.
-/
def isForwardImplDetailHypName (n : Name) : Bool :=
  (`__aesop.fwd).isPrefixOf n

def isForwardImplDetailHyp (ldecl : LocalDecl) : Bool :=
  ldecl.isImplementationDetail && isForwardImplDetailHypName ldecl.userName

def getForwardImplDetailHyps : MetaM (Array LocalDecl) := do
 let mut result := #[]
 for ldecl in ← getLCtx do
    if isForwardImplDetailHyp ldecl then
      result := result.push ldecl
  return result

def _root_.Aesop.clearForwardImplDetailHyps (goal : MVarId) : MetaM MVarId :=
  goal.withContext do
    let hyps ← getForwardImplDetailHyps
    goal.tryClearMany $ hyps.map (·.fvarId)

structure ForwardHypData where
  /--
  Types of the hypotheses that have already been added by forward reasoning.
  -/
  types : Array Expr
  /--
  Depths of the hypotheses that have already been added by forward reasoning.
  -/
  depths : Std.HashMap FVarId Nat

def getForwardHypData : MetaM ForwardHypData := do
  let ldecls ← getForwardImplDetailHyps
  let mut types := ∅
  let mut depths := ∅
  for ldecl in ldecls do
    types := types.push (← instantiateMVars ldecl.type)
    if let some (depth, name) := matchForwardImplDetailHypName ldecl.userName then
      if let some ldecl := (← getLCtx).findFromUserName? name then
        depths := depths.insert ldecl.fvarId depth
  return { types, depths }

namespace ForwardHypData

def containsTypeUpToIds (data : ForwardHypData) (type : Expr) : MetaM Bool :=
  data.types.anyM λ knownType =>
    exprsEqualUpToIds' type knownType (allowAssignmentDiff := true)

end ForwardHypData

/--
Mark hypotheses that, according to their name, are forward implementation detail
hypotheses, as implementation details. This is a hack that works around the
fact that certain tactics (particularly anything based on the revert-intro
pattern) can turn implementation detail hyps into regular hyps.
-/
def hideForwardImplDetailHyps (goal : MVarId) : MetaM MVarId :=
  goal.withContext do
    let mut lctx ← getLCtx
    let mut localInsts ← getLocalInstances
    let mut anyChange := false
    for ldecl in ← getLCtx do
      if ! ldecl.isImplementationDetail &&
         isForwardImplDetailHypName ldecl.userName then
        lctx := lctx.setKind ldecl.fvarId .implDetail
        localInsts := localInsts.erase ldecl.fvarId
        anyChange := true
    if ! anyChange then
      return goal
    let goal' ← mkFreshExprMVarAt lctx localInsts (← goal.getType)
    goal.assign goal'
    return goal'.mvarId!

end Aesop
