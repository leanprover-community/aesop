/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Tracing
import Aesop.Tree.Format
import Aesop.Tree.TreeM

open Lean
open Lean.Meta
open Std (HashMap)

/-
To extract a proof, we start in the `MetaM` state in which Aesop was called.
Then we iterate through the proven part of the tree, top to bottom, 'replaying'
the mvar assignments that were performed during the search. This means:

- For each goal `g`, we assign `g`'s pre-norm mvar to the term generated by
  normalisation. If `g` was proved by normalisation, we are done. Otherwise,
  we find the proving child rapp of `g` and descend into it.
- For each rapp `r`, we assign the post-norm mvar of `r`'s parent goal to the
  term generated by `r`. Additionally, we assign each mvar assigned by `r`.
  Then we descend into `r`'s children.
- For each mvar cluster `c`, we find the proven goal of `c` and descend into it.

When we assign a metavariable `m`, we must take some care:

- We must first declare `m` if it is not already declared.
- We must assign (and declare) any metavariables on which the assignment of `m`
  depends. We cannot assume that these assignments are meta-free, since they may
  contain metavariables that were only assigned later during the search. We
  also cannot assume that these are the *only* metavariables occurring in the
  assignments, since they may additionally contain delayed-assigned
  metavariables which depend on the unassigned metavariables.

We also replay env modifications in a similar fashion. We assume that rules only
add declarations to the environment.

If the root goal is not proven, we extract the goals after safe rule
applications. This means we proceed as above, but stop as soon as we reach the
first non-safe rule application. If a goal has multiple safe rule applications,
we arbitrarily choose the first one. (This should happen rarely in practice.)
-/

namespace Aesop

local macro "throwPRError " s:interpolatedStr(term) : term =>
  `(throwError m!"aesop: internal error during proof reconstruction: " ++ m!$s)


-- ## Copying Declarations

private def getNewConsts (oldEnv newEnv : Environment) :
    Array ConstantInfo := Id.run do
  let oldMap₂ := oldEnv.constants.map₂
  let newMap₂ := newEnv.constants.map₂
  if oldMap₂.size == newMap₂.size then
    #[]
  else
    newMap₂.foldl (init := #[]) λ cs n c =>
      if oldMap₂.contains n then cs else cs.push c

-- For each declaration `d` that appears in `newState` but not in
-- `oldState`, add `d` to the environment. We assume that the environment in
-- `newState` is a local extension of the environment in `oldState`, meaning
--
-- 1. The declarations in `newState` are a superset of the declarations in
--    `oldState`.
-- 2. The `map₁`s of the environments in `newState` and `oldState` are
--    identical. (These contain imported decls.)
private def copyNewDeclarations (oldEnv newEnv : Environment) : CoreM Unit := do
  let newConsts := getNewConsts oldEnv newEnv
  setEnv $ newConsts.foldl (init := ← getEnv) λ env c => env.add c

open Match in
private def copyMatchEqnsExtState (oldEnv newEnv : Environment) : CoreM Unit := do
  let oldState := matchEqnsExt.getState oldEnv
  let newState := matchEqnsExt.getState newEnv
  if newState.map.size > oldState.map.size then
    for (n, eqns) in newState.map do
      if !oldState.map.contains n then
        registerMatchEqns n eqns

-- ## Copying Metavariables

private def copyMVarDecl (s : Meta.SavedState) (mvarId : MVarId) :
    MetaM Unit := do
  let decl ← s.runMetaM' $ do
    let decl ← getMVarDecl mvarId
    aesop_trace[extraction] "declare ?{mvarId.name} : {decl.type}"
    pure decl
  modifyMCtx λ mctx => { mctx with decls := mctx.decls.insert mvarId decl }

private partial def copyExprMVarAssignment (s : Meta.SavedState)
    (mvarId : MVarId) : MetaM Unit := do
  if ← isExprMVarAssigned mvarId <||> isMVarDelayedAssigned mvarId then
    return
  unless ← isExprMVarDeclared mvarId do
    copyMVarDecl s mvarId
  let assignment? ← s.runMetaM' do
    if let (some e) ← getExprMVarAssignment? mvarId then
      return some $ Sum.inl (← instantiateMVars e)
    else if let (some d) ← getDelayedMVarAssignment? mvarId then
      return some $ Sum.inr d
    else
      return none
  match assignment? with
  | some (Sum.inl e) =>
    for mvarId in ← getMVars e do
      copyExprMVarAssignment s mvarId
    aesop_trace[extraction] "assign  ?{mvarId.name} := {toString e}"
    assignExprMVar mvarId e
  | some (Sum.inr d) =>
    for mvarId in ← getMVars d.val do
      copyExprMVarAssignment s mvarId
    aesop_trace[extraction] "dassign ?{mvarId.name} := {d.fvars} => {toString d.val}"
    delayedAssignMVar mvarId d
  | none => return

-- ## Main Functions

private def visitGoal (g : Goal) : MetaM (Option (MVarId × Array RappRef)) := do
  aesop_trace[extraction] "visiting {← g.toMessageData (← TraceModifiers.get)}"
  match g.normalizationState with
  | NormalizationState.notNormal => throwPRError
    "goal {g.id} was not normalised."
  | NormalizationState.normal postNormGoal postState =>
    copyExprMVarAssignment postState g.preNormGoal
    return (postNormGoal, g.children)
  | NormalizationState.provenByNormalization postState =>
    copyExprMVarAssignment postState g.preNormGoal
    return none

private def visitRapp (parentEnv : Environment) (parentGoal : MVarId) (r : Rapp) :
    MetaM (Array MVarClusterRef × Environment) := do
  aesop_trace[extraction] "visiting {← r.toMessageData}"
  let newEnv := r.metaState.core.env
  copyNewDeclarations parentEnv newEnv
  copyMatchEqnsExtState parentEnv newEnv
  copyExprMVarAssignment r.metaState parentGoal
  for m in r.assignedMVars do
    copyExprMVarAssignment r.metaState m
  return (r.children, newEnv)

mutual
  private partial def extractProofGoal (parentEnv : Environment) (g : Goal) :
      MetaM Unit := do
    match ← visitGoal g with
    | some (postNormGoal, children) => do
      let rref? ← children.findM? λ rref => return (← rref.get).state.isProven
      let (some rref) := rref? | throwPRError
        "goal {g.id} does not have a proven rapp."
      extractProofRapp parentEnv postNormGoal (← rref.get)
    | none => return

  private partial def extractProofRapp (parentEnv : Environment)
      (parentGoal : MVarId) (r : Rapp) : MetaM Unit := do
    let (children, newEnv) ← visitRapp parentEnv parentGoal r
    children.forM λ cref => do extractProofMVarCluster newEnv (← cref.get)

  private partial def extractProofMVarCluster (parentEnv : Environment)
      (c : MVarCluster) : MetaM Unit := do
    let gref? ← c.goals.findM? λ gref => return (← gref.get).state.isProven
    let (some gref) := gref? | throwPRError
      "an mvar cluster does not contain a proven goal (candidate goals: {← c.goals.mapM λ gref => return (← gref.get).id})."
    extractProofGoal parentEnv (← gref.get)
end

private structure SafePrefixState where
  goals : Array MVarId := #[]
  hasMultiplePrefixes := false
    -- True if a goal had multiple safe rapps. This can happen with safe
    -- multi-rules.

private abbrev SafePrefixM := StateRefT SafePrefixState MetaM

mutual
  private partial def extractFirstSafePrefixGoal
      (parentEnv : Environment) (g : Goal) : SafePrefixM Unit := do
    match ← visitGoal g with
    | none => return
    | some (postNormGoal, _) =>
      let safeRapps ← g.safeRapps
      if h : 0 < safeRapps.size then
        extractFirstSafePrefixRapp parentEnv postNormGoal
          (← safeRapps[⟨0, h⟩].get)
        if safeRapps.size > 1 then
          modify λ s => { s with hasMultiplePrefixes := true }
      else
        modify λ s => { s with goals := s.goals.push postNormGoal }

  private partial def extractFirstSafePrefixRapp
      (parentEnv : Environment) (parentGoal : MVarId) (r : Rapp) :
      SafePrefixM Unit := do
    let (children, env) ← visitRapp parentEnv parentGoal r
    children.forM λ cref => do
      extractFirstSafePrefixMVarCluster env (← cref.get)

  private partial def extractFirstSafePrefixMVarCluster
      (parentEnv : Environment) (c : MVarCluster) : SafePrefixM Unit :=
    c.goals.forM λ gref => do extractFirstSafePrefixGoal parentEnv (← gref.get)
end

def Goal.extractFirstSafePrefix (root : Goal) : MetaM (Array MVarId × Bool) := do
  let (_, state) ← extractFirstSafePrefixGoal (← getEnv) root |>.run {}
  return (state.goals, state.hasMultiplePrefixes)

def Goal.extractProof (root : Goal) : MetaM Unit := do
  extractProofGoal (← getEnv) root

def extractProof : TreeM Unit := do
  (← (← getRootGoal).get).extractProof

def extractFirstSafePrefix : TreeM (Array MVarId × Bool) := do
  (← (← getRootGoal).get).extractFirstSafePrefix

end Aesop
