/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Tree.Data

open Lean
open Lean.Meta

namespace Aesop

/-!
The following functions let us run MetaM actions in the context of a rapp or
goal. Rapps save the metavariable context in which they were run by storing a
`Meta.SavedState`. When we, for example, apply a rule to a goal, we run the
rule's action in the metavariable context of the goal (which is the
metavariable context of the goal's parent rapp). The resulting metavariable
context, in which the goal mvar is assigned to an expression generated by the
rule, then becomes the metavariable context of the rule's rapp.

To save and restore metavariable contexts, we use the `MonadBacktrack MetaM`
instance. This means that some elements of the state are persistent, notably
caches and trace messages. These become part of the global state.

The environment is not persistent. This means that modifications of the
environment made by a rule are not visible in the global state and are reset
once the tactic exits. As a result, rules which modify the environment are
likely to fail.
-/

variable [Monad m] [MonadLiftT MetaM m] [MonadFinally m]

local instance : MonadLiftT (ST IO.RealWorld) m where
  monadLift x := (x : MetaM _)

@[inline, always_inline]
private def withSaveState (x : m α) : m (α × Meta.SavedState) := do
  let r ← x
  let s ← Meta.saveState
  return (r, s)

def Rapp.runMetaM' (x : m α) (r : Rapp) : m α :=
  runInMetaState r.metaState x

def Rapp.runMetaM (x : m α) (r : Rapp) : m (α × Meta.SavedState) :=
  r.runMetaM' do withSaveState x

def Rapp.runMetaMModifying (x : m α) (r : Rapp) : m (α × Rapp) := do
  let (result, finalState) ← r.runMetaM x
  return (result, r |>.setMetaState finalState)

def RappRef.runMetaMModifying (x : m α) (rref : RappRef) : m α := do
  let (result, r) ← (← rref.get).runMetaMModifying x
  rref.set r
  return result

def Goal.runMetaMInPostNormState' [MonadError m] (x : MVarId → m α) (g : Goal) :
    m α := do
  let some (postGoal, postState) := g.postNormGoalAndMetaState? | throwError
    "aesop: internal error: expected goal {g.id} to be normalised (but not proven by normalisation)."
  runInMetaState postState $ x postGoal

def Goal.runMetaMInPostNormState [MonadError m] (x : MVarId → m α) (g : Goal) :
    m (α × Meta.SavedState) :=
  g.runMetaMInPostNormState' λ g => withSaveState (x g)

def Goal.runMetaMInParentState' (x : m α) (g : Goal) : m α := do
  match ← show MetaM _ from g.parentRapp? with
  | none =>
    let initialState ← Meta.saveState
    try
      x
    finally
      initialState.restore
  | some rref => (← rref.get).runMetaM' x

def Goal.runMetaMInParentState (x : m α) (g : Goal) : m (α × Meta.SavedState) :=
  g.runMetaMInParentState' do withSaveState x

def Goal.runMetaMModifyingParentState (x : m α) (g : Goal) : m α := do
  match ← show MetaM _ from g.parentRapp? with
  | none => x
  | some rref => rref.runMetaMModifying x

def Rapp.runMetaMInParentState (x : m α) (r : Rapp) :
    m (α × Meta.SavedState) := do
  (← r.parent.get).runMetaMInParentState x

def Rapp.runMetaMInParentState' (x : m α) (r : Rapp) : m α := do
  (← r.parent.get).runMetaMInParentState' x

def Rapp.runMetaMModifyingParentState (x : m α) (r : Rapp) : m α := do
  (← r.parent.get).runMetaMModifyingParentState x

end Aesop
